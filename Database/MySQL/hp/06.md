---
sidebar: auto
prev: /Database/MySQL/hp/05.md
next: /Database/MySQL/hp/07.md
---

# 6 查询性能优化
查询优化，索引优化，库表结构优化需要齐头并进。查询的生命周期大致可以按照顺序来看：从客户的，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。

其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。

## 6.2 慢查询基础：优化数据访问
1. 是否像数据库请求了不需要的数据
2. MySQL是否在扫描额外的记录。最简单的衡量查询开销的三个指标，**响应时间**，**扫描的行数和访问类型**和**返回的行数**。如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：
   - 使用索引覆盖扫描，把所有需要用的列都放到索引中
   - 改变库表结构
   - 重写这个复杂的查询

## 6.3 重构查询的方式
### 6.3.2 切分查询
有时候对于一个大查询需要“分而治之”，将大查询切分成小查询。比如删除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多的数据，占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。如：
```sql
DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVAL 3 MONTH);
```
可以优化为：
```
rows_affected = 0
do {
    rows_affeced = do_query(
        "DELETE FROM messages WHERE created < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"
    )
} while rows_affected > 0
```

### 6.3.3 分解关联查询
例子：
```sql
SELECT * FROM tag
    JOIN tag_post ON tag_post.tag_id = tag.id
    JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = 'mysql';
```
可以分解为下面的查询语句：
```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id = 1234;
SELECT * FROM post WHERE post_id in (123,455,678,2344,5566);
```
分解后的重构有如下优势：
- 让缓存的效率更高。应用程序可以方便的缓存单表的查询结果对象
- 执行单个查询可以减少锁的竞争
- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
- 查询本剩效率也可能会有所提升。用`IN()`代替关联查询，可以让MySQL按ID顺序查询，这可能比随机的关联查询更高效
- 可以减少冗余查询记录
- 在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联

## 6.4 查询执行的基础
根据下图，可以看到向MySQL发送一个请求的时候，MySQL到底做了什么。

![查询执行路径](./images/sql_execution.png)



