---
sidebar: auto
---

# MySQL架构和历史
## 1.2 并发控制
只要有多个查询需要在同一个时刻修改数据，都会产生并发控制的问题。

### 1.2.1 读写锁
在处理并发读或写时，可以通过两种锁解决问题，这两种锁通常被称为 **共享锁(shared lock)** 和 **排他锁(exclusive lock)**, 也叫 读锁(read lock) 和 写锁(write lock)。

### 1.2.2 锁的力度
所有锁的策略，就是在锁的开销和数据的安全性之间的寻求平衡，这种平衡也会影响到性能。每种MySQL引擎都实现了自己的锁策略和锁粒度。最重要的两种锁策略：

**表锁(table lock)**

MySQL最基本的锁策略，也是开销最小的策略。一个用户在对表进行写操作时，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作！只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不互相阻塞的。

尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的，如服务器会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略引擎的锁机制。

**行级锁(row lock)**
行级锁可以最大程度的支持并发处理，但同时也带来了最大的锁开销问题。在InnoDB和XtraDB实现了行级锁。行级锁只在存储引擎层实现，而在MySQL服务器层没有实现。

## 1.3 事务
一个运行良好的事务处理系统，必须具有ACID这些标准特征：
- `原子性(atomicity)` 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作，要么全部提交成功，要么全部回滚失败。对于一个事务来说，不可以执行其中的一部分操作，这就是事务的原子性。
- `一致性(consistency)`   数据库总是从一个一致性状态转换到另一个一致性的状态。没有提交的事务所做的修改不会写到数据库中。
- `隔离性(isolation)`   一个事务在提交之前，对其他事务是不可见的。
- `持久性(durability)`  一旦事务被提交，则其所做的所有修改就会永久保存在数据库中。

